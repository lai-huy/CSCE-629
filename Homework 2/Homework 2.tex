\documentclass{article}
\usepackage{amsmath,amssymb,amsthm,latexsym,paralist}
\usepackage{minted}

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newtheorem*{solution}{Solution}
\newtheorem*{resources}{Resources}

\newcommand{\name}[1]{\noindent\textbf{Name: {#1}}}
\newcommand{\honor}{\noindent On my honor, as an Aggie, I have neither
  given nor received any unauthorized aid on any portion of the
  academic work included in this assignment. Furthermore, I have
  disclosed all resources (people, books, web sites, etc.) that have
  been used to prepare this homework. \\[1ex]
 \textbf{Signature:} \underline{\hspace*{5cm}} }

\newcommand{\checklist}{\noindent\textbf{Checklist:}
\begin{compactitem}[$\Box$] 
\item Did you add your name? 
\item Did you disclose all resources that you have used? \\
(This includes all people, books, websites, etc. that you have consulted)
\item Did you sign that you followed the Aggie honor code? 
\item Did you solve all problems? 
\item Did you write the solution in your own words? 
\item Did you submit the pdf file of your homework?
\end{compactitem}
}

\newcommand{\problemset}[1]{\begin{center}\textbf{Problem Set #1}\end{center}}
\newcommand{\duedate}[1]{\begin{quote}\textbf{Due dates:} Typeset your
    solution in \LaTeX{}. Electronic
    submission of the resulting .pdf file of this homework is due on
    \textbf{#1} on canvas. If your submission cannot be checked by
    turnitin, then it will not be graded.\end{quote} }

\newcommand{\N}{\mathbf{N}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\Z}{\mathbf{Z}}

\usepackage{tikz}
\usetikzlibrary{positioning}
\tikzset{face/.style={scale=0.5,shape=circle,minimum size=4ex,shading=radial,outer sep=0pt,
        inner color=white!50!yellow,outer color= yellow!70!orange}}

\newcommand{\aha}{%
\begin{tikzpicture}[scale=0.5]
     \node[face] {}; 
     \draw[fill=white] (-1ex,0ex) ..controls (-0.5ex,0.2ex)and(0.5ex,0.2ex)..
        (1ex,0.0ex) ..controls ( 1.5ex,1.5ex)and( 0.2ex,1.7ex)..
        (0ex,0.4ex) ..controls (-0.2ex,1.7ex)and(-1.5ex,1.5ex)..
        (-1ex,0ex)--cycle;
    \fill[shift={(0.5ex,0.5ex)},rotate=80] 
       (0,0) ellipse (0.3ex and 0.15ex);
  \fill[shift={(-0.5ex,0.5ex)},rotate=100] 
       (0,0) ellipse (0.3ex and 0.15ex);
  \draw[] (-1.5ex,-0.5ex)
               ..controls (-0.7ex,-1.7ex)and(0.7ex,-1.7ex)..(1.5ex,-0.5ex);
\end{tikzpicture}
}

\newcommand{\confused}{%     
\begin{tikzpicture}[scale=0.5]
  \node[face] {}; 
\draw[fill=white] (-1ex,0ex) ..controls (-0.5ex,0.2ex)and(0.5ex,0.2ex)..
        (1ex,0.0ex) ..controls ( 1.5ex,1.5ex)and( 0.2ex,1.7ex)..
        (0ex,0.4ex) ..controls (-0.2ex,1.7ex)and(-1.5ex,1.5ex)..
        (-1ex,0ex)--cycle;
    \fill[shift={(0.5ex,0.5ex)},rotate=80] 
       (0,0) ellipse (0.3ex and 0.15ex);
  \fill[shift={(-0.5ex,0.5ex)},rotate=100] 
       (0,0) ellipse (0.3ex and 0.15ex);
  \draw[] (-1ex,-0.75ex)--(1ex,-1.25ex);
\end{tikzpicture}
}


\begin{document}
\problemset{2}
\duedate{Friday, Feb 3, before 11:59pm}
\name{Huy Quang Lai}
\begin{resources} Cormen, Thomas H., Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. \textit{Introduction to Algorithms}. The MIT Press.
\end{resources}
\honor

\newpage

\noindent\textbf{Problem A.} Solve the following five subproblems. 

\begin{problem}[20 points] 
Give a self-contained proof of the fact that 
$$\log_2(n!)\in \Theta(n\log n).$$
[For part of your argument, you can use results that were given in the
lecture, but you should write up the proof in your own words. Make
sure that you write it in complete sentences, even when the sentence
contains formulas. A good check is to read out the entire solution
aloud. It should read smoothly.] 
\end{problem}
\begin{solution}
\begin{flalign*}
\log_2(n!)  &=\log_2(1)+\log_2(2)+\log_2(3)+\cdots+\log_2(n)    &\\
            &\leq\log_2(n)+\log_2(n)+\log_2(n)+\cdots+\log_2(n) &\\
            &=n\log_2(n)                                        &
\end{flalign*}

\begin{flalign*}
\log_2(n!)  &=\log_2(1)+\log_2(2)+\cdots\log_2\left(\frac{n}{2}\right)+\cdots+\log_2(n) &\\
            &\geq\log_2\left(\frac{n}{2}\right)+\log_2\left(\frac{n}{2}+1\right)+\cdots+\log_2(n-1)+\log_2(n)   &\\
            &=\frac{n}{2}\log_2\left(\frac{n}{2}\right) =\frac{n}{4}\log_2 n&
\end{flalign*}
$\displaystyle\because c_1n\log n\leq\log_2(n!)\leq c_2 n\log n,\forall n\geq1$\\
$\displaystyle\therefore \log_2(n!)\in\Theta(n\log n)$
\end{solution}  

\begin{problem}[20 points] 
  Amelia attempted to solve $n$ algorithmic problems. She wrote down
  one problem per page in her journal and marked the page with
  \confused when she was unable to solve the problem and with \aha
  when she was able to solve it. So the pages of her journal look like
  this: 
$$ 
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline
\vphantom{\Big|}\confused&\confused&\confused&\aha&\confused&\aha&\confused&\aha\\
\hline
\end{array}
$$
Use the decision tree method to show that any algorithm to find a page with an
\aha smiley on has to look at all $n$ pages in the worst case. 
\end{problem}
\begin{solution}
\[\]
\includegraphics[width=0.25\textwidth]{EpicTree.png}

\noindent
In the worst case, Amelia could not solve any problems and all pages are \confused.\\
However, the algorithm must first search through all pages of her journal to determine if this is true.
\end{solution}  

\begin{problem}[20 points] 
  Amelia attempted to solve $n$ algorithmic problems. She wrote down
  one problem per page in her journal and marked the page with
  \confused when she was unable to solve the problem and with \aha
  when she was able to solve it. So the pages of her journal look like
  this: 
$$ 
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline
\vphantom{\Big|}\confused&\confused&\confused&\aha&\confused&\aha&\confused&\aha\\
\hline
\end{array}
$$
Use an adversary method to show that any method to find a page with a
\aha smiley on it might have to look at all $n$ pages. 
\end{problem}
\begin{solution}
\[\]
No matter what algorithm is used, it is possible that all $n-1$ pages checked are \confused and the algorithm must check the $n$-th page to determine if it is \aha or \confused.\\ Therefore, the algorithm must check all $n$ pages to guarantee if the journal contains a \aha.
\end{solution}  

\begin{problem}[20 points] 
  Amelia attempted to solve $n$ algorithmic problems, where $n$ is an
  odd number. She wrote down one problem per page in her journal and
  marked the page with \confused when she was unable to solve the
  problem and with \aha when she was able to solve it. Suppose that we
  want to find the pattern $\confused$, where she was unable to
  solve a problem, but was able to solve the subsequent problem. 

  \noindent
  Find an algorithm that always looks at fewer than $n$ pages but is
  able to correctly find the pattern when it exists. [Hint: First look
  at all even pages.] 
\end{problem}
\begin{solution}
\[\]
Loop through the journal looking at only the even-numbered pages.\\
If the page is \aha, then the algorithm needs to check the previous page for \confused.
If the page is \confused, then the algorithm needs to check the next page for \aha.\\
This algorithm guarantees that fewer than $n$ pages are checked. This is because no matter the arrangement of \aha and \confused, there is always at least one page that is not checked.
\end{solution}

\clearpage
\begin{problem}[20 points]
Suppose that we are given a sorted array $A[1..n]$ of $n$ numbers. Our
goal is to determine whether or not the array $A$ contains
duplicate elements. We will limit ourselves to algorithms that use only the spaceship
operator \verb|<=>| for comparisons, where 
\begin{verbatim}
a <=> b :=
  if a < b then return -1
  if a = b then return  0
  if a > b then return  1
  if a and b are not comparable then return nil
\end{verbatim}
No other methods will be used to compare or inspect elements of the
array. 
\begin{enumerate}[(a)]
\item Give an efficient (optimal) comparison-based algorithm that decides
  whether $A[1..n]$ contains duplicates using the spaceship operator
  for comparisons. 
\item Use an adversarial argument to show that no algorithm can solve
  the problem with fewer calls to the comparison operator \verb|<=>|
  than the algorithm that you gave in (a). 
\end{enumerate}
\end{problem}
\begin{solution}
\[\]
Assuming the array is zero indexed.
\begin{minted}{cpp}
for (size_t i = 0; i < A.size() - 1; ++i) {
    if ((A[i] <=> A[i + 1]) == 0)
        return true;
    return false;
}
\end{minted}
In the worst case, this algorithm need $n-1$ comparisons.

\noindent
The algorithm must check all $n-1$ pairs of consecutive elements to guarantee that a duplicate element exists. If the algorithm does not check all pairs, it is possible that the two unchecked elements are equal to each other.
\end{solution}
\end{document}
